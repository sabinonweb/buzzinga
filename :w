use crate::args::{AppConfig, Args, RedditConfig};
use anyhow::{Context, Error, Ok};
use base64::{engine::general_purpose, Engine};
use clap::builder::Str;
use log4rs::encode::json::JsonEncoder;
use reqwest::{
    header::{HeaderMap, AUTHORIZATION, CONTENT_TYPE, USER_AGENT},
    Client, StatusCode,
};
use serde::Deserialize;
use std::{collections::HashMap, fs::File, io::Read, sync::Arc};

const REDDIT_TOKEN_URL: &str = "https://www.reddit.com/api/v1/access_token";

macro_rules! env_variable {
    ($key:ident) => {
        std::env::var(stringify!($key))
            .context(concat!(stringify!($key), " not found in dotenv config."))?
    };
}

#[derive(Debug, Clone, Deserialize)]
pub struct AccessToken {
    access_token: String,
    token_type: String,
    expires_in: i64,
    scope: String,
}

/// Redis OAuth client for interacting with reddit API
pub struct RedditClient {
    // reqwest client for interacting with the reddit API
    pub(crate) client: Client,

    // access token that is received after authorization
    pub(crate) token: String,

    // user agent in the standard format!
    pub(crate) user_agent: String,
}

impl RedditClient {
    /// For creation of oauth client, `Resource Owner Password Credentials Grant` is used
    pub(crate) async fn new(args: &Args) -> anyhow::Result<RedditClient> {
        let reddit_config = config(&args)?;

        let token = get_token(&reddit_config).await?;
        let mut headers = HeaderMap::new();
        headers.insert(AUTHORIZATION, token.access_token.parse()?);
        headers.insert(USER_AGENT, reddit_config.user_agent.parse()?);

        let client = Client::builder().default_headers(headers).build()?;

        Ok(RedditClient {
            client,
            token: token.access_token,
            user_agent: reddit_config.user_agent,
        })
    }
}

async fn get_token(reddit_config: &RedditConfig) -> anyhow::Result<AccessToken> {
    let basic_header = format!(
        "Basic {}",
        general_purpose::STANDARD.encode(format!(
            "{}:{}",
            &reddit_config.client_id, &reddit_config.client_secret
        ))
    );

    let mut headers = HeaderMap::new();
    headers.insert(AUTHORIZATION, basic_header.parse()?);
    headers.insert(USER_AGENT, reddit_config.user_agent.parse()?);
    headers.insert(CONTENT_TYPE, "application/x-www-form-urlencoded".parse()?);

    let mut params = HashMap::new();
    params.insert("grant_type", "password");
    params.insert("username", &reddit_config.client_username);
    params.insert("password", &reddit_config.client_password);

    let response = Client::new()
        .post(REDDIT_TOKEN_URL)
        .headers(headers)
        .form(&[
            ("grant_type", "password"),
            ("username", &reddit_config.client_username),
            ("password", &reddit_config.client_password),
        ])
        .send()
        .await?;
    // println!("respnse; {:?}", response.text().await?);

    // println!("{:?}", &response.bytes().await?);
    // if response.status().is_success() {
    //     let token = response.json().await?;
    //     println!("token: {:?}", token);
    //     Ok(token)
    // } else {
    //     return Err(Error::msg(response.status()));
    // }
    //
    //
    if response.status().is_success() {
        let token: AccessToken = serde_json::from_str(&response.text().await?)?;
        println!("Deserialized token: {:?}", token);
        Ok(token)
    } else {
        Err(Error::msg(format!(
            "Failed to fetch access token. Status: {}",
            response.status()
        )))
    } // let token: AccessToken = serde_json::from_str(&response.text().await?)?;
      // println!("acc: {:?}", token);
      // Ok(AccessToken {
      //     access_token: String::new(),
      //     token_type: String::new(),
      //     expires_in: 36,
      //     scope: "*".to_string(),
      // })
      //
      // let res: Vec<String> = response.json().await?;
      //
      // println!("Response: {:?}", res);

    // match response.status() {
    //     StatusCode::OK => Ok(AccessToken {
    //         access_token: response.text().await?.access_token,
    //     }),
    //     _ => {
    //         log::error!("Response couldn't succeed! Error while reading response json!");
    //         Err(Error::msg("Status: Internal Server Error")
    //             .context("Response couldn't succeed! Error while reading response json!"))
    //     }
    // }
    // //
    // Ok(AccessToken {
    //     access_token: String::from("Setia:"),
    // })
}

pub(crate) fn config(args: &Args) -> anyhow::Result<RedditConfig> {
    dotenv::from_path(&args.dotenv).context("Error while reading file path of dotenv file!")?;

    let app_config: AppConfig = {
        let file_path = &args.config;
        let mut config_file =
            File::open(file_path).context("File path for the config file not found!")?;
        let mut file_content = String::new();

        config_file
            .read_to_string(&mut file_content)
            .context("Error occured while reading file contents!")?;

        toml::from_str(&file_content.as_str())?
    };

    let client_username = env_variable!(CLIENT_USERNAME);
    let client_id = env_variable!(CLIENT_ID);
    let client_secret = env_variable!(CLIENT_SECRET);
    let client_password = env_variable!(CLIENT_PASSWORD);
    let user_agent = format!(
        "{}:{}:v.{} (by {client_username})",
        &app_config.environment, &app_config.application_name, &app_config.version
    );

    Ok(RedditConfig {
        client_id,
        client_username,
        client_password,
        client_secret,
        user_agent,
    })
}
